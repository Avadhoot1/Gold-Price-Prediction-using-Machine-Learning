# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17w12Gp7ppVxKDF0O6a4AK1IDgBA5XkxF
"""

import pandas as pd
import numpy as np

# Read your dataset
gold = pd.read_csv("/content/gold.csv")

gold

# 1. Convert Date column to datetime
gold["Date"] = pd.to_datetime(gold["Date"])

gold["Date"]

# 2. Set Date as index (useful for time-series analysis)
gold.set_index("Date", inplace=True)

# Check result
print(gold.head())
print(gold.index)

gold.loc["2005-01-01":"2005-12-31"]   # Get all data for 2005

gold.loc["2008"].head()
# First rows of 2008

if "Currency" in gold.columns:
    gold.drop(columns=["Currency"], inplace=True)

# Save cleaned version again
gold.to_csv("gold_cleaned_no_currency.csv")

print("âœ… 'Currency' column deleted. New file saved as gold_cleaned_no_currency.csv")

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score

gold = pd.read_csv("gold_cleaned_no_currency.csv", parse_dates=["Date"], index_col="Date")

X = gold[["Open", "High", "Low", "Volume"]]   # input features
y = gold["Close"]                             # target variable

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False  # no shuffle for time-series
)

rf = RandomForestRegressor(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

y_pred = rf.predict(X_test)

print("ðŸ“Š Model Evaluation")
print("Mean Absolute Error (MAE):", mean_absolute_error(y_test, y_pred))
print("RÂ² Score:", r2_score(y_test, y_pred))

last_row = X.iloc[[-1]]   # latest dayâ€™s features
next_day_pred = rf.predict(last_row)

print("\nðŸ’° Predicted Next Day Close Price:", next_day_pred[0])

"""Now Plot the Close, Open, High , low, Volume"""

import matplotlib.pyplot as plt

plt.figure(figsize=(14,6))
plt.plot(gold.index, gold["Open"], label="Open", alpha=0.7)
plt.plot(gold.index, gold["High"], label="High", alpha=0.7)
plt.plot(gold.index, gold["Low"], label="Low", alpha=0.7)
plt.plot(gold.index, gold["Close"], label="Close", alpha=0.9, linewidth=2)

plt.title("Gold Prices (Open, High, Low, Close)")
plt.xlabel("Date")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

"""Plot Volume separately"""

plt.figure(figsize=(14,4))
plt.bar(gold.index, gold["Volume"], color="orange", alpha=0.6)
plt.title("Gold Trading Volume")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.show()

"""Line plot comparison"""

plt.figure(figsize=(14,6))
plt.plot(gold.index, gold["Open"], label="Open Price", alpha=0.7)
plt.plot(gold.index, gold["Close"], label="Close Price", alpha=0.9, linewidth=2)

plt.title("Gold: Open vs Close Price")
plt.xlabel("Date")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

"""Difference (Close - Open)"""

gold["Diff"] = gold["Close"] - gold["Open"]

plt.figure(figsize=(14,4))
plt.plot(gold.index, gold["Diff"], color="purple", alpha=0.8)
plt.axhline(0, color="red", linestyle="--")
plt.title("Difference between Close and Open (Close - Open)")
plt.xlabel("Date")
plt.ylabel("Price Difference (USD)")
plt.grid(True)
plt.show()

bullish_days = (gold["Diff"] > 0).sum()
bearish_days = (gold["Diff"] < 0).sum()
neutral_days = (gold["Diff"] == 0).sum()

total_days = len(gold)

"""Percentages"""

bullish_pct = bullish_days / total_days * 100
bearish_pct = bearish_days / total_days * 100
neutral_pct = neutral_days / total_days * 100

print("ðŸ“Š Gold Open vs Close Statistics")
print(f"Total trading days: {total_days}")
print(f"Days gold closed higher (bullish): {bullish_days} ({bullish_pct:.2f}%)")
print(f"Days gold closed lower (bearish): {bearish_days} ({bearish_pct:.2f}%)")
print(f"Days gold closed same as open: {neutral_days} ({neutral_pct:.2f}%)")

y_pred = rf.predict(X_test)

print("ðŸ“Š Model Evaluation")
print("Mean Absolute Error (MAE):", mean_absolute_error(y_test, y_pred))
print("RÂ² Score:", r2_score(y_test, y_pred))

last_row = X.iloc[[-1]]
next_day_pred = rf.predict(last_row)

print("\nðŸ’° Predicted Next Day Close Price:", next_day_pred[0])

plt.figure(figsize=(14,6))
plt.plot(y_test.index, y_test.values, label="Actual Close Price", color="blue")
plt.plot(y_test.index, y_pred, label="Predicted Close Price", color="red", linestyle="--")
plt.title("Actual vs Predicted Gold Close Prices")
plt.xlabel("Date")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

"""Short-term next-day prediction"""

last_row = X.iloc[[-1]]
next_day_pred = rf.predict(last_row)
print("ðŸ’° Predicted Next Day Close Price:", next_day_pred[0])

import pandas as pd

# Put actual and predicted into a dataframe
results = pd.DataFrame({
    "Actual": y_test.values,
    "Predicted": y_pred
}, index=y_test.index)

print(results.head(20))  # show first 20 rows

# Save results to CSV for further analysis
results.to_csv("/content/gold_cleaned_no_currency.csv")
import matplotlib.pyplot as plt

plt.figure(figsize=(14,6))
plt.plot(results.index, results["Actual"], label="Actual Close Price", color="blue")
plt.plot(results.index, results["Predicted"], label="Predicted Close Price", color="red", linestyle="--")

plt.title("Actual vs Predicted Gold Close Prices")
plt.xlabel("Date")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Predictions on test set
y_pred = rf.predict(X_test)

# Accuracy metrics
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print("ðŸ“Š Model Evaluation Metrics")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"RÂ² Score: {r2:.4f}")

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

y_pred = rf.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print("MAE:", mae)
print("RMSE:", rmse)
print("RÂ²:", r2)

mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
accuracy = 100 - mape

print(f"MAPE: {mape:.2f}%")
print(f"Accuracy: {accuracy:.2f}%")